//
//  KKEncryptionHelper.swift
//  KKPinView
//
//  Created by kamalkumar on 27/12/25.
//

import Foundation
import CryptoKit

/// A helper for encrypting and decrypting data using AES-256-GCM encryption.
///
/// `KKEncryptionHelper` provides high-level encryption/decryption functionality using:
/// - **AES-256**: Advanced Encryption Standard with 256-bit keys
/// - **GCM Mode**: Galois/Counter Mode for authenticated encryption
/// - **Secure Key**: Uses keys generated by `KKSecureKeyGenerator`
///
/// ## Features
/// - **Authenticated Encryption**: GCM mode provides both confidentiality and authenticity
/// - **Automatic Nonce Generation**: Each encryption uses a unique random nonce
/// - **Secure Key Handling**: Works with base64-encoded secure keys
/// - **Error Handling**: Returns `nil` on failure with detailed error logging
///
/// ## Usage Example
/// ```swift
/// // Get secure key
/// let secureKey = KKSecureKeyGenerator.getOrCreateSecureKey()
///
/// // Encrypt data
/// let plaintext = "Sensitive data"
/// let plaintextData = plaintext.data(using: .utf8)!
/// if let encrypted = KKEncryptionHelper.encryptData(plaintextData, secureKey: secureKey) {
///     // Save encrypted data
///     let base64Encrypted = encrypted.base64EncodedString()
/// }
///
/// // Decrypt data
/// if let decrypted = KKEncryptionHelper.decryptData(encrypted, secureKey: secureKey) {
///     let decryptedString = String(data: decrypted, encoding: .utf8)
/// }
/// ```
///
/// ## Encryption Format
///
/// The encrypted data format is:
/// ```
/// [12 bytes: Nonce] + [N bytes: Ciphertext] + [16 bytes: Authentication Tag]
/// ```
///
/// - **Nonce**: 12-byte random nonce for GCM mode
/// - **Ciphertext**: Encrypted data (same length as plaintext)
/// - **Tag**: 16-byte authentication tag for integrity verification
///
/// ## Security Considerations
/// - Uses AES-256-GCM, which is considered secure for most applications
/// - Each encryption uses a unique nonce (never reuse nonces with the same key)
/// - The authentication tag prevents tampering
/// - Keys must be 32 bytes (256 bits) for AES-256
///
/// ## Error Handling
/// - Returns `nil` if encryption/decryption fails
/// - Logs detailed error messages to console
/// - Validates input parameters before processing
///
/// - Note: Available on iOS 15.0 and later
@available(iOS 15.0, *)
public enum KKEncryptionHelper {
    
    /// Encrypts data using AES-256-GCM with the provided secure key.
    ///
    /// This method:
    /// 1. Validates the input parameters
    /// 2. Derives a 32-byte key from the base64-encoded secure key
    /// 3. Generates a random 12-byte nonce
    /// 4. Encrypts the data using AES-GCM
    /// 5. Combines nonce, ciphertext, and authentication tag
    ///
    /// - Parameters:
    ///   - data: The data to encrypt (any `Data` object)
    ///   - secureKey: Base64 encoded secure key string (from `KKSecureKeyGenerator`)
    /// - Returns: Encrypted data containing nonce + ciphertext + tag, or `nil` if encryption fails
    ///
    /// ## Example
    /// ```swift
    /// let pin = "1234"
    /// let pinData = pin.data(using: .utf8)!
    /// let key = KKSecureKeyGenerator.getOrCreateSecureKey()
    ///
    /// if let encrypted = KKEncryptionHelper.encryptData(pinData, secureKey: key) {
    ///     // Successfully encrypted
    ///     print("Encrypted: \(encrypted.base64EncodedString())")
    /// } else {
    ///     // Encryption failed
    ///     print("Encryption failed")
    /// }
    /// ```
    public static func encryptData(_ data: Data, secureKey: String) -> Data? {
        guard !data.isEmpty, !secureKey.isEmpty else {
            print("❌ EncryptData: Invalid input parameters")
            return nil
        }
        
        do {
            // Derive key from secure key string
            guard let keyData = Data(base64Encoded: secureKey) else {
                print("❌ EncryptData: Invalid base64 key")
                return nil
            }
            
            // Use first 32 bytes as key (AES-256 requires 32 bytes)
            let keyBytes = Array(keyData.prefix(32))
            guard keyBytes.count == 32 else {
                print("❌ EncryptData: Key length must be 32 bytes")
                return nil
            }
            
            // Create symmetric key
            let symmetricKey = SymmetricKey(data: keyBytes)
            
            // Generate random nonce (12 bytes for GCM)
            let nonce = AES.GCM.Nonce()
            
            // Encrypt using AES-GCM
            let sealedBox = try AES.GCM.seal(data, using: symmetricKey, nonce: nonce)
            
            // Combine nonce + ciphertext + tag
            var combined = Data()
            combined.append(contentsOf: nonce)
            combined.append(sealedBox.ciphertext)
            combined.append(sealedBox.tag)
            
            return combined
        } catch {
            print("❌ Encryption error: \(error.localizedDescription)")
            return nil
        }
    }
    
    /// Decrypts data using AES-256-GCM with the provided secure key.
    ///
    /// This method:
    /// 1. Validates the input parameters
    /// 2. Extracts nonce, ciphertext, and tag from the encrypted data
    /// 3. Derives a 32-byte key from the base64-encoded secure key
    /// 4. Decrypts and verifies the data using AES-GCM
    ///
    /// - Parameters:
    ///   - encryptedData: The encrypted data (nonce + ciphertext + tag) from `encryptData(_:secureKey:)`
    ///   - secureKey: Base64 encoded secure key string (must match the key used for encryption)
    /// - Returns: Decrypted data, or `nil` if decryption fails
    ///
    /// ## Example
    /// ```swift
    /// let key = KKSecureKeyGenerator.getOrCreateSecureKey()
    ///
    /// if let decrypted = KKEncryptionHelper.decryptData(encryptedData, secureKey: key) {
    ///     let pin = String(data: decrypted, encoding: .utf8)
    ///     print("Decrypted PIN: \(pin ?? "nil")")
    /// } else {
    ///     print("Decryption failed - wrong key or corrupted data")
    /// }
    /// ```
    ///
    /// - Important: The `secureKey` must be the same key used for encryption.
    ///   Using a different key will result in decryption failure.
    public static func decryptData(_ encryptedData: Data, secureKey: String) -> Data? {
        guard !encryptedData.isEmpty, !secureKey.isEmpty else {
            print("❌ DecryptData: Invalid input parameters")
            return nil
        }
        
        do {
            // Derive key from secure key string
            guard let keyData = Data(base64Encoded: secureKey) else {
                print("❌ DecryptData: Invalid base64 key")
                return nil
            }
            
            // Use first 32 bytes as key (AES-256 requires 32 bytes)
            let keyBytes = Array(keyData.prefix(32))
            guard keyBytes.count == 32 else {
                print("❌ DecryptData: Key length must be 32 bytes")
                return nil
            }
            
            // Extract components
            // GCM nonce: 12 bytes, tag: 16 bytes, rest is ciphertext
            guard encryptedData.count >= 28 else {
                print("❌ DecryptData: Encrypted data too short")
                return nil
            }
            
            let nonceData = encryptedData.prefix(12)
            let tagData = encryptedData.suffix(16)
            let ciphertextData = encryptedData.dropFirst(12).dropLast(16)
            
            guard let nonce = try? AES.GCM.Nonce(data: nonceData),
                  let tag = try? AES.GCM.SealedBox.Tag(tagData) else {
                print("❌ DecryptData: Failed to extract nonce or tag")
                return nil
            }
            
            // Create sealed box
            let sealedBox = try AES.GCM.SealedBox(
                nonce: nonce,
                ciphertext: ciphertextData,
                tag: tag
            )
            
            // Create symmetric key
            let symmetricKey = SymmetricKey(data: keyBytes)
            
            // Decrypt
            let decryptedData = try AES.GCM.open(sealedBox, using: symmetricKey)
            
            return decryptedData
        } catch {
            print("❌ Decryption error: \(error.localizedDescription)")
            return nil
        }
    }
}

